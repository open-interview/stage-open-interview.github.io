{"questions":[{"id":"q-235","question":"What is the purpose of Cypress fixtures and how do you load fixture data in a component test?","answer":"Fixtures provide static test data. Use cy.fixture('data.json').as('testData') to load JSON files for component testing.","explanation":"## Cypress Fixtures Overview\n\nFixtures are external data files that provide static test data for your Cypress tests. They help separate test data from test logic, making tests more maintainable and readable.\n\n## Implementation Details\n\n- Fixtures are stored in the `cypress/fixtures/` directory by default\n- Support JSON, JS, and other file formats\n- Can be loaded using `cy.fixture()` command\n- Data is cached during test runs for performance\n\n## Code Example\n\n```javascript\n// cypress/fixtures/user-data.json\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n\n// cypress/component/UserComponent.spec.js\ndescribe('UserComponent', () => {\n  beforeEach(() => {\n    cy.fixture('user-data').as('userData')\n  })\n  \n  it('displays user information', function() {\n    cy.mount(UserComponent, { props: { user: this.userData } })\n    cy.get('[data-cy=user-name]').should('contain', 'John Doe')\n  })\n})\n```\n\n## Common Pitfalls\n\n- Using `function() {}` instead of arrow functions to access fixture data via `this`\n- Not properly handling async fixture loading\n- Storing sensitive data in fixtures (use environment variables instead)","diagram":"flowchart LR\n    A[Test File] --> B[cy.fixture()]\n    B --> C[Fixtures Directory]\n    C --> D[JSON/JS Files]\n    D --> E[Loaded Data]\n    E --> F[Component Test]\n    F --> G[Assertions]","difficulty":"beginner","tags":["cypress","component-testing","fixtures"],"channel":"e2e-testing","subChannel":"cypress","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=BQqzfHQkREo","longVideo":"https://www.youtube.com/watch?v=ZAICTaRLHxE"},"companies":["Airbnb","Amazon","Google","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-21T08:57:30.524Z","createdAt":"2025-12-25 12:50:53"},{"id":"q-449","question":"How would you design an E2E testing strategy for a distributed edge computing platform that needs to validate functionality across 100+ global data centers with varying network conditions?","answer":"Implement a hierarchical testing approach with regional test orchestration hubs. Use Playwright with custom browser contexts to simulate different network conditions and geographic locations. Deploy t","explanation":"## Architecture\n- **Regional Test Hubs**: Deploy test orchestration in major geographic regions\n- **Network Simulation**: Use browser APIs to throttle bandwidth and increase latency\n- **Parallel Execution**: Run tests concurrently across regions with centralized coordination\n\n## Key Components\n- **Test Agents**: Lightweight services executing Playwright tests locally\n- **Result Aggregation**: Central service collecting and normalizing test results\n- **Health Monitoring**: Real-time dashboard showing test coverage and failure rates\n\n## Implementation Strategy\n```typescript\n// Regional test orchestration\nclass RegionalTestHub {\n  async runTestsAcrossRegions(testSuite: TestSuite) {\n    const regions = await this.getActiveRegions();\n    const results = await Promise.allSettled(\n      regions.map(region => this.executeTestInRegion(testSuite, region))\n    );\n    return this.aggregateResults(results);\n  }\n}\n```","diagram":"flowchart TD\n  A[Central Orchestrator] --> B[Regional Hub NA]\n  A --> C[Regional Hub EU]\n  A --> D[Regional Hub APAC]\n  B --> E[Edge Node 1]\n  B --> F[Edge Node 2]\n  C --> G[Edge Node 3]\n  C --> H[Edge Node 4]\n  D --> I[Edge Node 5]\n  D --> J[Edge Node 6]\n  E --> K[Browser Context]\n  F --> K\n  G --> K\n  H --> K\n  I --> K\n  J --> K\n  K --> L[Test Results]\n  L --> M[Aggregation Service]\n  M --> N[Dashboard]","difficulty":"advanced","tags":["e2e-testing"],"channel":"e2e-testing","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Cloudflare","Tesla"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-24T02:40:35.627Z","createdAt":"2025-12-25 12:50:54"},{"id":"q-460","question":"You're testing a login form with Playwright. The form has email and password fields, and a submit button. How would you write a basic E2E test to verify successful login and redirect to dashboard?","answer":"Use Playwright's test() function with page.locator() to find elements. Fill credentials with fill(), click submit, then waitForURL() or expect(page.url()).toContain('/dashboard'). Add assertions for d","explanation":"## Key Concepts\n- E2E testing simulates real user interactions\n- Playwright provides cross-browser automation\n- Test structure: Arrange-Act-Assert pattern\n\n## Implementation Steps\n- Navigate to login page\n- Locate form elements using selectors\n- Fill input fields with test data\n- Submit form and wait for response\n- Verify redirect and dashboard content\n\n## Best Practices\n- Use data-testid attributes for stable selectors\n- Implement proper waiting strategies\n- Handle async operations with await\n- Clean up test data after execution","diagram":"flowchart TD\n  A[Navigate to Login] --> B[Locate Form Elements]\n  B --> C[Fill Credentials]\n  C --> D[Click Submit]\n  D --> E[Wait for Redirect]\n  E --> F[Verify Dashboard]","difficulty":"beginner","tags":["e2e-testing"],"channel":"e2e-testing","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Lyft","MongoDB","NVIDIA"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-24T02:46:02.502Z","createdAt":"2025-12-25 12:50:55"},{"id":"q-491","question":"How would you set up a basic E2E test for a login form using Playwright?","answer":"Use Playwright's test runner to create a test that navigates to the login page, fills credentials using `page.fill()`, clicks submit with `page.click()`, and verifies successful login by checking URL ","explanation":"## Test Setup\n- Install Playwright: `npm i @playwright/test`\n- Create test file: `login.spec.ts`\n\n## Key Steps\n- Navigate: `await page.goto('/login')`\n- Fill form: `await page.fill('#email', 'user@test.com')`\n- Submit: `await page.click('#submit')`\n- Assert: `await expect(page).toHaveURL('/dashboard')`\n\n## Best Practices\n- Use `test.describe()` for grouping\n- Add `test.beforeEach()` for setup\n- Use data-testid selectors for stability","diagram":"flowchart TD\n  A[Navigate to Login] --> B[Fill Email]\n  B --> C[Fill Password]\n  C --> D[Click Submit]\n  D --> E[Verify Success]","difficulty":"beginner","tags":["e2e-testing"],"channel":"e2e-testing","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["IBM","Lyft","Snowflake"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-25T01:14:21.393Z","createdAt":"2025-12-25 12:50:55"},{"id":"q-279","question":"What are the key differences between getByRole() and getByText() selectors in Playwright, and when would you choose one over the other for reliable E2E testing?","answer":"getByRole() locates elements by their ARIA role and accessible name, making it more resilient to UI text changes and better for accessibility testing. getByText() matches visible text content directly, which can be brittle but useful for specific text validation. Prefer getByRole() for user interactions and getByText() only when text content is the actual test assertion.","explanation":"## Selector Reliability\ngetByRole() is more maintainable as it focuses on semantic meaning rather than visual presentation. It survives UI redesigns and internationalization changes.\n\n## Accessibility Benefits\ngetByRole() ensures your app is screen-reader compatible by testing the same attributes assistive technologies use.\n\n## When to Use Each\n- **getByRole()**: Buttons, links, form controls, navigation\n- **getByText()**: Error messages, static labels, content validation\n\n## Common Pitfalls\ngetByText() can match multiple elements or fail with dynamic content. getByRole() requires proper ARIA implementation.\n\n## Performance Considerations\ngetByRole() is generally faster as it leverages browser accessibility tree, while getByText() requires DOM traversal and text matching.\n\n```javascript\n// Good: Semantic interaction\nawait page.getByRole('button', { name: 'Submit' }).click();\n\n// Good: Content validation\nexpect(page.getByText('Success!')).toBeVisible();\n\n// Bad: Brittle text selection\nawait page.getByText('Click here').click(); // Fails if text changes\n```","diagram":"flowchart TD\n    A[Start Test] --> B{Need Element?}\n    B -->|User Action| C[Use getByRole]\n    B -->|Text Content| D[Use getByText]\n    B -->|Form Input| E[Use getByLabel]\n    B -->|Last Resort| F[Use getByTestId]\n    \n    C --> G[Auto-wait & Retry]\n    D --> G\n    E --> G\n    F --> G\n    \n    G --> H[Perform Action]\n    H --> I[Assert Results]","difficulty":"beginner","tags":["playwright","browser-automation","selectors"],"channel":"e2e-testing","subChannel":"playwright","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-23T06:27:27.673Z","createdAt":"2025-12-25 12:50:54"},{"id":"q-208","question":"What is the difference between Selenium WebDriver and Selenium Grid, and when would you use each in your testing strategy?","answer":"WebDriver controls single browsers locally; Grid manages multiple browsers across machines for parallel test execution and cross-browser testing.","explanation":"## Why Asked\nInterview context: Tests understanding of Selenium architecture and scalable testing approaches\n## Key Concepts\nCore knowledge: WebDriver for single browser automation, Grid for distributed testing, parallel execution, cross-browser compatibility\n## Code Example\n```\n// WebDriver setup\nWebDriver driver = new ChromeDriver();\n\n// Grid setup\nDesiredCapabilities caps = new DesiredCapabilities();\ncaps.setBrowserName(\"chrome\");\nWebDriver driver = new RemoteWebDriver(gridUrl, caps);\n```\n## Follow-up Questions\nCommon follow-ups: How do you configure Grid nodes? What's the difference between Grid 3 and 4? How do you handle flaky tests?","diagram":"flowchart TD\n  A[Test Strategy] --> B{Single Browser?}\n  B -->|Yes| C[WebDriver]\n  B -->|No| D[Grid]\n  C --> E[Local Testing]\n  D --> F[Parallel Testing]\n  D --> G[Cross-Browser Testing]","difficulty":"beginner","tags":["selenium","webdriver","grid"],"channel":"e2e-testing","subChannel":"selenium","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":"https://www.youtube.com/watch?v=0kgI92z3J7M"},"companies":["Amazon","Google","Meta"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-21T08:53:13.355Z","createdAt":"2025-12-25 12:50:53"}],"subChannels":["cypress","general","playwright","selenium"],"companies":["Airbnb","Amazon","Cloudflare","Google","IBM","Lyft","Meta","Microsoft","MongoDB","NVIDIA","Snowflake","Tesla","Uber"],"stats":{"total":6,"beginner":5,"intermediate":0,"advanced":1,"newThisWeek":6}}