{"questions":[{"id":"q-236","question":"How would you implement a contract testing strategy using MSW (Mock Service Worker) to ensure frontend API mocks stay synchronized with backend OpenAPI specifications?","answer":"Use MSW with OpenAPI schema validation, generating mocks from spec and running contract tests in CI to detect drift.","explanation":"## Contract Testing with MSW\n\n**Concept Overview**: MSW intercepts requests at the network level, allowing you to mock APIs while validating against OpenAPI contracts to prevent frontend-backend drift.\n\n**Implementation Details**:\n- Generate MSW handlers from OpenAPI spec using tools like `openapi-msw`\n- Validate request/response payloads against schema\n- Run contract tests in CI pipeline\n- Use response mocking with schema validation\n\n**Code Example**:\n```typescript\n// Generate handlers from OpenAPI\nimport { setupWorker, rest } from 'msw';\nimport { validateAgainstSchema } from './schema-validator';\n\nconst handlers = [\n  rest.get('/api/users/:id', async (req, res, ctx) => {\n    const userId = req.params.id;\n    const response = { id: userId, name: 'John' };\n    \n    // Validate against OpenAPI schema\n    if (!validateAgainstSchema(response, 'UserSchema')) {\n      return res(ctx.status(500), ctx.json({ error: 'Schema violation' }));\n    }\n    \n    return res(ctx.json(response));\n  })\n];\n\nsetupWorker(...handlers).start();\n```\n\n**Common Pitfalls**:\n- Schema validation only in test environment, not production mocks\n- Not updating mocks when API spec changes\n- Missing edge cases in contract tests\n- Over-mocking leading to false confidence","diagram":"flowchart LR\n    A[OpenAPI Spec] --> B[MSW Handler Generator]\n    B --> C[MSW Mock Handlers]\n    C --> D[Frontend App]\n    C --> E[Schema Validator]\n    E --> F[Contract Tests]\n    F --> G[CI Pipeline]\n    G --> H{Schema Valid?}\n    H -->|Yes| I[Tests Pass]\n    H -->|No| J[Fail Build]","difficulty":"intermediate","tags":["wiremock","mockserver","msw"],"channel":"api-testing","subChannel":"contract-testing","sourceUrl":null,"videos":null,"companies":["LinkedIn","Meta","Microsoft","Stripe","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T05:08:39.160Z","createdAt":"2025-12-23 12:53:08"},{"id":"q-453","question":"You're testing a REST API that returns paginated results. The endpoint has a rate limit of 100 requests per minute and sometimes returns 500 errors under load. How would you design a comprehensive test strategy?","answer":"Implement load testing with gradual ramp-up using tools like k6 or JMeter. Add retry logic with exponential backoff for 500 errors. Use request batching to stay within rate limits. Monitor response ti","explanation":"## Test Strategy Components\n\n- **Load Testing**: Simulate realistic user traffic patterns\n- **Rate Limiting**: Implement request throttling and batching\n- **Error Handling**: Test retry mechanisms and circuit breakers\n- **Contract Testing**: Validate API responses against schemas\n- **Monitoring**: Track performance metrics and error rates\n\n## Tools & Implementation\n\n```javascript\n// Example retry logic with exponential backoff\nconst retryRequest = async (url, retries = 3) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url);\n      if (response.ok) return response;\n      if (response.status === 500) {\n        await new Promise(resolve => \n          setTimeout(resolve, Math.pow(2, i) * 1000));\n        continue;\n      }\n    } catch (error) {\n      if (i === retries - 1) throw error;\n    }\n  }\n};\n```\n\n## Key Considerations\n\n- Test both success and failure scenarios\n- Validate pagination consistency\n- Check data integrity under concurrent load\n- Monitor resource utilization during tests","diagram":"flowchart TD\n  A[Load Test Setup] --> B[Gradual Ramp-up]\n  B --> C[Monitor Response Times]\n  C --> D{500 Errors?}\n  D -->|Yes| E[Apply Retry Logic]\n  D -->|No| F[Continue Load]\n  E --> G[Exponential Backoff]\n  G --> H[Rate Limit Check]\n  H --> I[Batch Requests]\n  I --> J[Contract Validation]\n  J --> K[Performance Metrics]","difficulty":"intermediate","tags":["api-testing"],"channel":"api-testing","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Airbnb","Google","Lyft"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-24T02:45:06.763Z","createdAt":"2025-12-24T02:45:06.763Z"},{"id":"q-209","question":"How would you design a REST API testing framework that handles rate limiting, circuit breaking, and distributed tracing for microservices with 10,000+ concurrent requests?","answer":"Implement async request batching with token bucket rate limiting, Hystrix circuit patterns, and OpenTelemetry tracing across test suites.","explanation":"## Concept Overview\nProduction-scale REST testing requires sophisticated concurrency control and observability. The framework must simulate real-world load while maintaining test reliability.\n\n## Implementation Details\n- **Rate Limiting**: Token bucket algorithm with distributed Redis counters\n- **Circuit Breaking**: Hystrix-style failure threshold with exponential backoff\n- **Distributed Tracing**: OpenTelemetry span propagation across service boundaries\n- **Request Batching**: Async HTTP client pools with connection multiplexing\n\n## Code Example\n```javascript\n// Rate-limited test executor\nclass LoadTestExecutor {\n  constructor(rateLimit, circuitBreaker) {\n    this.tokenBucket = new TokenBucket(rateLimit);\n    this.circuitBreaker = circuitBreaker;\n  }\n\n  async executeTest(testSuite) {\n    const span = tracer.startSpan('rest-test');\n    await this.tokenBucket.acquire();\n    return this.circuitBreaker.execute(async () => {\n      return testSuite.run(span);\n    });\n  }\n}\n```\n\n## Common Pitfalls\n- Ignoring connection pool exhaustion\n- Inadequate error propagation in distributed traces\n- Circuit breaker threshold misconfiguration\n- Memory leaks in async test cleanup","diagram":"graph TD\n    A[Test Suite] --> B[Token Bucket]\n    B --> C[Circuit Breaker]\n    C --> D[HTTP Client Pool]\n    D --> E[Microservice A]\n    D --> F[Microservice B]\n    C --> G[OpenTelemetry Tracer]\n    G --> H[Jaeger Collector]\n    B --> I[Redis Rate Store]\n    C --> J[Hystrix Metrics]","difficulty":"advanced","tags":["postman","rest-assured","supertest"],"channel":"api-testing","subChannel":"rest-testing","sourceUrl":null,"videos":null,"companies":["Amazon","Goldman Sachs","Microsoft","Netflix","Stripe"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-21T12:47:26.342Z","createdAt":"2025-12-23 12:53:08"}],"subChannels":["contract-testing","general","rest-testing"],"companies":["Airbnb","Amazon","Goldman Sachs","Google","LinkedIn","Lyft","Meta","Microsoft","Netflix","Stripe","Uber"],"stats":{"total":3,"beginner":0,"intermediate":2,"advanced":1,"newThisWeek":3}}