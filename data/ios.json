{"questions":[{"id":"q-464","question":"How would you implement a custom UICollectionViewFlowLayout that supports dynamic cell heights and sticky headers while maintaining smooth scrolling performance?","answer":"Use `prepare()` to calculate attributes, cache them in a dictionary, and implement `shouldInvalidateLayout(forBoundsChange:)` to handle sticky headers. Optimize with `estimatedItemSize` and avoid expe","explanation":"## Key Implementation Steps\n\n- Override `prepare()` to calculate and cache layout attributes\n- Implement `layoutAttributesForElements(in:)` for visible elements\n- Use `shouldInvalidateLayout(forBoundsChange:)` for sticky headers\n- Set `estimatedItemSize` for dynamic heights\n\n## Performance Optimizations\n\n- Cache calculations to avoid repeated work\n- Use `UICollectionViewFlowLayoutInvalidationContext` for targeted updates\n- Implement `targetContentOffset(forProposedContentOffset:)` for smooth scrolling\n\n## Common Pitfalls\n\n- Don't perform expensive calculations in `layoutAttributesForElements(in:)`\n- Handle rotation and size changes properly\n- Manage memory for cached attributes","diagram":"flowchart TD\n  A[prepare() - Calculate Attributes] --> B[Cache in Dictionary]\n  B --> C[layoutAttributesForElements]\n  C --> D[shouldInvalidateLayout]\n  D --> E[Sticky Headers Logic]\n  E --> F[Smooth Scrolling]","difficulty":"intermediate","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Lyft","Meta"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-24T02:46:33.607Z","createdAt":"2025-12-25 12:50:55"},{"id":"q-495","question":"How would you implement a simple UITableView with custom cells in iOS using Swift?","answer":"Create a UITableViewCell subclass, register it with tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\"), implement UITableViewDataSource methods (numberOfRowsInSection, cellForRow","explanation":"## Implementation Steps\n- Create custom UITableViewCell class with outlets\n- Register cell class or nib with table view\n- Implement UITableViewDataSource protocol\n- Configure cells in cellForRowAt method\n- Handle cell selection and data updates\n\n## Key Concepts\n- Reusable cell pattern for performance\n- Delegation pattern for table view events\n- Auto Layout for cell sizing\n- Data source management","diagram":"flowchart TD\n  A[Create Custom Cell] --> B[Register Cell]\n  B --> C[Implement DataSource]\n  C --> D[Configure Cell]\n  D --> E[Handle Selection]","difficulty":"beginner","tags":["ios"],"channel":"ios","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Oracle","Snowflake","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-25T01:14:50.195Z","createdAt":"2025-12-25 12:50:55"},{"id":"q-181","question":"Explain the difference between weak and unowned references in Swift and provide practical use cases for each?","answer":"weak: optional, nils automatically when object deallocates. unowned: non-optional, assumes object exists, crash if accessed after deallocation.","explanation":"## Why Asked\nTests memory management understanding and preventing retain cycles in iOS development\n## Key Concepts\n- Automatic Reference Counting (ARC)\n- Strong reference cycles\n- Optional vs non-optional references\n- Lifetime expectations\n## Code Example\n```\nclass Parent {\n    weak var child: Child?\n    unowned let partner: Parent\n}\n\n// weak: when object might become nil (e.g., delegates)\n// unowned: when object outlives reference (e.g., parent-child)\n```\n## Follow-up Questions\n- How do you identify retain cycles?\n- What happens when you access an unowned reference after deallocation?\n- When should you use strong references instead?","diagram":"flowchart TD\n  A[Object Created] --> B{Reference Type?}\n  B -->|May become nil| C[weak var]\n  B -->|Always exists| D[unowned]\n  C --> E[Becomes nil on deallocation]\n  D --> F[Crashes if accessed after deallocation]","difficulty":"intermediate","tags":["swift","language"],"channel":"ios","subChannel":"swift","sourceUrl":null,"videos":{"shortVideo":"https://www.youtube.com/watch?v=bMNwHNOVdXw","longVideo":"https://www.youtube.com/watch?v=8KQcTDGqQEc"},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":"Imagine you're playing with building blocks! A 'weak' reference is like saying 'I'm looking at my friend's red block.' If your friend takes their block away, you just shrug and say 'Oh well, no red block anymore!' You don't cry or break anything. An 'unowned' reference is like saying 'I'm holding my friend's blue block and I KNOW it's there!' If your friend secretly takes the block away and you try to grab it, you'll trip and fall because you expected it to be there! Use weak references when you're just watching something that might disappear (like watching a toy car that might drive away). Use unowned references when you're absolutely sure something will stay there (like holding onto your mom's hand while crossing the street).","relevanceScore":null,"lastUpdated":"2025-12-25T12:48:56.713Z","createdAt":"2025-12-25 12:50:55"},{"id":"q-257","question":"What is optional chaining in Swift and how does it prevent runtime crashes when accessing nested optional properties?","answer":"Optional chaining (?.) safely unwraps optionals, returning nil if any link fails instead of throwing runtime errors.","explanation":"## Optional Chaining Overview\n\nOptional chaining is a Swift feature that allows you to safely access properties, methods, and subscripts of optional values. If any optional in the chain is nil, the entire chain returns nil instead of crashing.\n\n### Implementation Details\n\n- Uses the `?.` operator to chain optional accesses\n- Returns an optional value of the expected type\n- Short-circuits when it encounters nil\n- Can be used with properties, methods, and subscripts\n\n### Code Example\n\n```swift\nclass Person {\n    var residence: Residence?\n}\n\nclass Residence {\n    var address: Address?\n}\n\nclass Address {\n    var street: String\n    \n    init(street: String) {\n        self.street = street\n    }\n}\n\nlet person = Person()\nlet street = person.residence?.address?.street // returns nil, not crash\n\n// Safe optional chaining\nif let street = person.residence?.address?.street {\n    print(\"Street: \\(street)\")\n} else {\n    print(\"Address not available\")\n}\n```\n\n### Common Pitfalls\n\n- Forgetting that optional chaining always returns an optional\n- Using forced unwrapping (!) instead of safe chaining\n- Not handling the nil case appropriately\n- Over-chaining when a simpler optional binding would be clearer","diagram":"graph TD\n    A[person] --> B[residence?]\n    B --> C[address?]\n    C --> D[street: String]\n    \n    E[Optional Chaining ?. ] --> F{Check residence}\n    F -->|nil| G[Return nil]\n    F -->|exists| H{Check address}\n    H -->|nil| G\n    H -->|exists| I[Return street value]\n    \n    style G fill:#ffcccc\n    style I fill:#ccffcc","difficulty":"beginner","tags":["optionals","protocols","generics"],"channel":"ios","subChannel":"swift","sourceUrl":"https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html","videos":{"shortVideo":null,"longVideo":null},"companies":["Apple","Google","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T08:33:39.554Z","createdAt":"2025-12-25 12:50:54"},{"id":"q-204","question":"How would you optimize a UITableView with 10,000+ complex cells using Auto Layout while maintaining 60fps scrolling and memory efficiency?","answer":"Use cell reuse, pre-calculate heights, implement heightForRowAt caching, and optimize Auto Layout constraints with manual layout when needed.","explanation":"## Concept Overview\nOptimizing large UITableViews requires balancing memory usage, rendering performance, and smooth scrolling. Auto Layout adds computational overhead that becomes critical at scale.\n\n## Implementation Details\n\n### Cell Reuse Strategy\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    // Reset expensive operations\n    imageView.image = nil\n    complexView.resetContent()\n}\n```\n\n### Height Caching System\n```swift\nprivate var heightCache: [IndexPath: CGFloat] = [:]\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    if let cached = heightCache[indexPath] {\n        return cached\n    }\n    let height = calculateHeight(for: indexPath)\n    heightCache[indexPath] = height\n    return height\n}\n```\n\n### Auto Layout Optimization\n- Use `setNeedsLayout()` instead of `layoutIfNeeded()`\n- Prefer `intrinsicContentSize` over complex constraints\n- Implement `systemLayoutSizeFitting` for height calculation\n\n### Memory Management\n- Use weak references for cell closures\n- Implement `didEndDisplaying` for cleanup\n- Consider async image loading with placeholder\n\n## Common Pitfalls\n- Not caching heights leads to expensive recalculations\n- Complex Auto Layout in cell configuration blocks\n- Memory leaks from strong reference cycles\n- Ignoring cell reuse lifecycle","diagram":"flowchart LR\n    A[User Scrolls] --> B[dequeueReusableCell]\n    B --> C{Height Cached?}\n    C -->|Yes| D[Use Cached Height]\n    C -->|No| E[Calculate Height]\n    E --> F[Cache Height]\n    F --> G[Configure Cell]\n    G --> H[Apply Constraints]\n    H --> I[Render Cell]\n    I --> J[Display]\n    D --> G","difficulty":"advanced","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Capital One","Lyft","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T04:51:19.765Z","createdAt":"2025-12-25 12:50:53"},{"id":"q-232","question":"How does Auto Layout constraint resolution work when creating a UITableView with dynamic cell heights?","answer":"Auto Layout resolves constraints by calculating required cell heights based on content, then UITableView applies these heights during layout.","explanation":"## Concept Overview\nAuto Layout constraint resolution is the process where iOS calculates the size and position of views based on their constraints. For UITableView with dynamic cells, this happens in two phases.\n\n## Implementation Details\n1. **System Layout Size Fitting**: UITableView calls `systemLayoutSizeFitting` on each cell prototype\n2. **Constraint Resolution**: Auto Layout engine resolves all constraints to determine cell height\n3. **Height Caching**: UITableView caches calculated heights for performance\n4. **Layout Application**: Heights are applied during the table view's layout pass\n\n## Code Example\n```swift\n// In UITableViewCell subclass\noverride func awakeFromNib() {\n    super.awakeFromNib()\n    // Enable auto-sizing\n    contentView.translatesAutoresizingMaskIntoConstraints = false\n}\n\n// In UITableViewController\ntableView.rowHeight = UITableView.automaticDimension\ntableView.estimatedRowHeight = 100\n```\n\n## Common Pitfalls\n- Missing `translatesAutoresizingMaskIntoConstraints = false`\n- Incomplete constraint chains leading to ambiguous layouts\n- Performance issues with complex constraint hierarchies\n- Not setting `estimatedRowHeight` causing layout delays","diagram":"graph TD\n    A[UITableView] --> B[Cell Prototype]\n    B --> C[Auto Layout Engine]\n    C --> D[Constraint Resolution]\n    D --> E[Height Calculation]\n    E --> F[Height Caching]\n    F --> G[Layout Application]\n    G --> H[Final Cell Display]","difficulty":"beginner","tags":["autolayout","tableview","collectionview"],"channel":"ios","subChannel":"uikit","sourceUrl":null,"videos":null,"companies":["Airbnb","Apple","Google","Meta","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T05:08:12.994Z","createdAt":"2025-12-25 12:50:53"}],"subChannels":["general","swift","uikit"],"companies":["Airbnb","Amazon","Apple","Capital One","Google","Lyft","Meta","Microsoft","Oracle","Snowflake","Uber"],"stats":{"total":6,"beginner":3,"intermediate":2,"advanced":1,"newThisWeek":6}}