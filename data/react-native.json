{"questions":[{"id":"q-475","question":"You're building a React Native app with complex animations that need to run at 60fps. The app has multiple animated components including a custom carousel, gesture-driven interactions, and background video processing. How would you optimize performance to maintain smooth animations?","answer":"Use **React Native's Reanimated 3** for UI thread animations, avoid JS bridge overhead. Implement **useAnimatedStyle** with **useDerivedValue** for efficient value sharing. Use **FlattenList** instead","explanation":"## Performance Optimization Strategy\n\n### Animation Framework\n- **Reanimated 3**: Runs animations on UI thread, prevents JS bridge blocking\n- **Shared Values**: Efficient state management across animation boundaries\n- **Worklets**: JS code executed on UI thread for smooth 60fps\n\n### List Optimization\n- **FlatList**: Virtualized rendering with memory efficiency\n- **removeClippedSubviews**: Hides off-screen items to reduce render load\n- **getItemLayout**: Provides fixed item heights for optimized scrolling\n\n### Gesture Handling\n- **Gesture Handler**: Native gesture recognition system\n- **PanGestureHandler**: Smooth drag interactions without JS overhead\n\n### Profiling Tools\n- **Flipper**: Debug performance bottlenecks and memory usage\n- **React DevTools**: Identify unnecessary re-renders\n\n### Render Optimization\n- **React.memo**: Prevent component re-renders when props unchanged\n- **useCallback**: Stabilize function references across renders","diagram":"flowchart TD\n  A[User Interaction] --> B[Gesture Handler]\n  B --> C[Reanimated Worklet]\n  C --> D[UI Thread Animation]\n  D --> E[60fps Render]\n  F[FlatList] --> G[Virtualized Items]\n  G --> H[removeClippedSubviews]\n  H --> E\n  I[React.memo] --> J[Optimized Re-renders]\n  J --> E","difficulty":"advanced","tags":["react-native"],"channel":"react-native","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","NVIDIA"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-24T02:48:10.108Z","createdAt":"2025-12-24 12:51:27"},{"id":"q-183","question":"What is the primary purpose of Native Modules in React Native and when would you use them?","answer":"To access native platform APIs and functionality not available in JavaScript, bridging gap between JS and native code.","explanation":"## Why Asked\nInterviewers test understanding of React Native's architecture and how to extend functionality beyond standard JavaScript APIs.\n\n## Key Concepts\n- Bridge communication between JavaScript and native code\n- Access to device hardware (camera, GPS, sensors)\n- Performance optimization for computationally intensive tasks\n- Third-party SDK integration\n\n## Code Example\n```\n// Android Native Module\n@ReactMethod\npublic void getDeviceInfo(Promise promise) {\n  try {\n    String deviceModel = Build.MODEL;\n    promise.resolve(deviceModel);\n  } catch (Exception e) {\n    promise.reject(\"ERROR\", e.getMessage());\n  }\n}\n\n// JavaScript usage\nimport { NativeModules } from 'react-native';\nconst { DeviceInfo } = NativeModules;\n\nconst getModel = async () => {\n  const model = await DeviceInfo.getDeviceInfo();\n  console.log(model);\n};\n```\n\n## Follow-up Questions\n- How does the React Native bridge work?\n- What are the performance implications of Native Modules?\n- How do you handle async operations in Native Modules?\n- What's the difference between Turbo Modules and legacy Native Modules?","diagram":"flowchart TD\n  A[JavaScript Code] --> B[React Native Bridge]\n  B --> C[Native Module]\n  C --> D[Platform API]\n  D --> E[Hardware/OS Features]\n  E --> F[Native Module]\n  F --> B\n  B --> A","difficulty":"beginner","tags":["native","bridge"],"channel":"react-native","subChannel":"native-modules","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Google","Meta"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T04:54:05.978Z","createdAt":"2025-12-24 12:51:25"},{"id":"q-206","question":"How would you optimize React Native list performance with Hermes and Reanimated when dealing with 10k+ items containing complex animations?","answer":"Use FlatList with getItemLayout, memoized items, Reanimated 2 shared values, Hermes bytecode optimization, and avoid inline functions.","explanation":"## Concept Overview\nOptimizing large lists in React Native requires addressing JavaScript execution, layout calculations, and animation performance simultaneously.\n\n## Implementation Details\n- **FlatList Optimization**: Use `getItemLayout`, `removeClippedSubviews`, and `maxToRenderPerBatch`\n- **Hermes Benefits**: Bytecode precompilation, reduced memory footprint, faster startup\n- **Reanimated 2**: Offload animations to UI thread using `useSharedValue` and `useAnimatedStyle`\n- **Memoization**: Prevent unnecessary re-renders with `React.memo` and `useCallback`\n\n## Code Example\n```javascript\nconst ListItem = React.memo(({ item, sharedValue }) => {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: sharedValue.value }]\n  }));\n\n  return (\n    <Animated.View style={[styles.item, animatedStyle]}>\n      <Text>{item.title}</Text>\n    </Animated.View>\n  );\n});\n\nconst OptimizedList = ({ data }) => {\n  const scale = useSharedValue(1);\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={({ item }) => <ListItem item={item} sharedValue={scale} />}\n      getItemLayout={(data, index) => ({ length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index })}\n      removeClippedSubviews={true}\n      maxToRenderPerBatch={10}\n      windowSize={10}\n    />\n  );\n};\n```\n\n## Common Pitfalls\n- Inline functions in renderItem causing re-renders\n- Not using getItemLayout leading to layout thrashing\n- Animations on JS thread instead of UI thread\n- Excessive prop drilling in list items\n- Ignoring Hermes bundle size optimization","diagram":"flowchart LR\n    A[10k+ Data Items] --> B[FlatList with getItemLayout]\n    B --> C[Memoized ListItem Components]\n    C --> D[Reanimated Shared Values]\n    D --> E[UI Thread Animations]\n    E --> F[Hermes Bytecode Execution]\n    F --> G[Optimized Rendering Pipeline]\n    \n    H[removeClippedSubviews] --> I[Reduced Memory Usage]\n    J[maxToRenderPerBatch] --> K[Controlled Rendering]\n    L[React.memo] --> M[Prevented Re-renders]\n    \n    I --> G\n    K --> G\n    M --> G","difficulty":"advanced","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":null,"companies":["Airbnb","Coinbase","Meta","Microsoft","Uber"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T04:45:11.662Z","createdAt":"2025-12-24 12:51:25"},{"id":"q-233","question":"How does the Hermes engine improve React Native app startup performance compared to JavaScriptCore, and what are the specific trade-offs?","answer":"Hermes uses ahead-of-time (AOT) compilation to convert JavaScript to optimized bytecode during build time, reducing startup by 30-50% and memory usage by 20-30% compared to JavaScriptCore's just-in-time (JIT) compilation. It pre-compiles functions, eliminating parsing overhead at runtime, and uses a more compact bytecode format. Trade-offs include longer build times, larger bundle sizes, and potentially slower execution for dynamically generated code.","explanation":"## Core Architecture Differences\n\n**JavaScriptCore (JIT)**:\n- Parses and compiles JavaScript at runtime\n- Uses baseline JIT, then optimizes hot code paths\n- Higher initial overhead but better for dynamic patterns\n\n**Hermes (AOT)**:\n- Compiles to optimized bytecode during build\n- No runtime parsing or compilation\n- Smaller memory footprint and faster initialization\n\n## Performance Impact\n\n```javascript\n// Bundle size comparison (typical app)\nJSC Bundle: ~1.2MB  + runtime compilation\nHermes Bundle: ~800KB (bytecode) + minimal runtime\n\n// Startup time benchmarks\nTime to Interactive:\n- JSC: 1.8-2.2s\n- Hermes: 0.9-1.4s\n```\n\n## Memory Usage\n\nHermes reduces memory usage through:\n- Pre-allocated memory pools\n- Efficient bytecode execution\n- No JIT compiler memory overhead\n- Conservative garbage collection\n\n## Trade-offs and Considerations\n\n**Advantages**:\n- Faster cold start performance\n- Lower memory consumption\n- Predictable performance (no JIT warmup)\n- Better crash rates in production\n\n**Limitations**:\n- Longer build times (AOT compilation)\n- Larger initial bundle size\n- Slower for eval() and dynamic imports\n- Limited debugging capabilities\n\n## Implementation\n\n```json\n// metro.config.js\n{\n  \"transformer\": \"metro-react-native-babel-transformer\",\n  \"resolver\": {\n    \"resolverMainFields\": [\"react-native\", \"browser\", \"main\"]\n  },\n  \"engines\": {\n    \"hermes\": true\n  }\n}\n```\n\n## When to Choose Hermes\n\n- **Production apps** prioritizing startup performance\n- **Memory-constrained devices** (entry-level phones)\n- **Apps with stable codebase** (limited dynamic code)\n- **Large user bases** where performance consistency matters\n\n## When JavaScriptCore Might Be Better\n\n- **Development environments** with frequent hot reloads\n- **Apps heavy on dynamic code generation**\n- **Debugging-intensive development**\n- **Prototype or experimental features**\n\nReal-world data from Facebook's internal testing shows Hermes reduces crash rates by 25% and improves user retention through faster app initialization, making it the preferred choice for production React Native applications.","diagram":"flowchart LR\n    A[JavaScript Source] --> B[Metro Bundler]\n    B --> C[Hermes AOT Compilation]\n    C --> D[Bytecode Bundle]\n    D --> E[App Installation]\n    E --> F[Faster Startup]\n    F --> G[Hermes Runtime]\n    G --> H[Native Bridge]","difficulty":"beginner","tags":["hermes","reanimated","profiling"],"channel":"react-native","subChannel":"performance","sourceUrl":null,"videos":null,"companies":null,"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-23T06:12:09.881Z","createdAt":"2025-12-24 12:51:27"}],"subChannels":["general","native-modules","performance"],"companies":["Airbnb","Amazon","Coinbase","Google","Meta","Microsoft","NVIDIA","Uber"],"stats":{"total":4,"beginner":2,"intermediate":0,"advanced":2,"newThisWeek":4}}