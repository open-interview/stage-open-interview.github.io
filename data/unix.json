{"questions":[{"id":"q-264","question":"How do Unix pipes enable inter-process communication and what are their performance implications?","answer":"Pipes provide unidirectional byte streams between processes, using kernel buffers for efficient IPC with blocking I/O semantics.","explanation":"## Why Asked\nTests understanding of IPC mechanisms and system design principles for scalable applications\n## Key Concepts\nUnidirectional communication, kernel buffering, blocking I/O, file descriptor abstraction, pipe capacity limits\n## Code Example\n```bash\n# Create pipe and connect processes\nls -l | grep \".txt\" | wc -l\n# Kernel manages 64KB buffer between processes\n```\n## Follow-up Questions\nWhat's the difference between named and anonymous pipes? How do pipes handle backpressure? What are alternatives to pipes?","diagram":"flowchart TD\n  A[Process A] -->|writes| B[Pipe Buffer]\n  B -->|reads| C[Process B]\n  D[Kernel] -->|manages| B","difficulty":"beginner","tags":["posix","signals","pipes","sockets"],"channel":"unix","subChannel":"fundamentals","sourceUrl":"https://man7.org/linux/man-pages/pipe.2","videos":{"shortVideo":null,"longVideo":null},"companies":["Amazon","Apple","Google","Meta","Microsoft"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-22T08:34:18.941Z","createdAt":"2025-12-25 12:50:54"},{"id":"q-481","question":"You're debugging a production system where processes are hanging. Using only Unix tools, how would you identify which processes are blocked on I/O, what they're waiting for, and safely terminate them without causing data corruption?","answer":"Use `lsof -p <PID>` to see open files and `strace -p <PID>` to identify blocked system calls. Check `/proc/<PID>/fd` for file descriptors. For safe termination, send SIGTERM first: `kill -15 <PID>`, w","explanation":"## Process Identification\n- `ps aux | grep D` shows processes in uninterruptible sleep\n- `top` with 'H' shows thread-level status\n- `iostat -x 1` identifies I/O bottlenecks\n\n## Root Cause Analysis\n- `strace -p <PID>` reveals blocked system calls\n- `lsof -p <PID>` shows open files and network connections\n- `/proc/<PID>/status` provides process state details\n\n## Safe Termination\n- SIGTERM allows graceful shutdown\n- Check for child processes before killing\n- Verify no critical writes in progress","diagram":"flowchart TD\n  A[Detect hanging process] --> B[ps aux | grep D]\n  B --> C[strace -p PID]\n  C --> D[lsof -p PID]\n  D --> E{Safe to terminate?}\n  E -->|Yes| F[kill -15 PID]\n  E -->|No| G[Wait for I/O completion]\n  F --> H[Monitor with ps]\n  G --> F","difficulty":"advanced","tags":["unix"],"channel":"unix","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["Snap","Snowflake"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-24T02:49:08.682Z","createdAt":"2025-12-25 12:50:55"},{"id":"q-510","question":"You're debugging a production issue where a process is stuck in uninterruptible sleep (D state). How would you identify and handle this situation?","answer":"Use `ps aux | awk '$8 ~ /D/ {print $2, $11}'` to find D-state processes. Check `dmesg | grep -i oom` for OOM killer activity. For I/O issues, use `lsof -p <PID>` to identify blocked files. If it's NFS","explanation":"## Identifying D-State Processes\n\n- Use `ps` with state filtering to find uninterruptible processes\n- Check system logs for hardware or filesystem errors\n- Examine I/O queues and block device status\n\n## Common Causes\n\n- NFS mount issues or network storage problems\n- Faulty hardware devices (disk, controller)\n- Kernel bugs or driver issues\n- Memory pressure causing I/O blocking\n\n## Resolution Strategies\n\n- Wait for hardware timeout (usually 30-120 seconds)\n- Check and fix underlying storage issues\n- Reboot as last resort if process won't recover\n- Monitor `/proc/<PID>/stack` for kernel call trace\n\n## Prevention\n\n- Monitor I/O performance metrics\n- Use proper timeout configurations for network storage\n- Implement health checks for critical storage systems","diagram":"flowchart TD\n  A[Process enters D state] --> B{Identify cause}\n  B --> C[Hardware issue]\n  B --> D[Network storage]\n  B --> E[Kernel/driver]\n  C --> F[Check dmesg/logs]\n  D --> G[Verify mount status]\n  E --> H[Examine stack trace]\n  F --> I[Wait or fix hardware]\n  G --> J[Resolve network/storage]\n  H --> K[Update/reboot if needed]","difficulty":"intermediate","tags":["unix"],"channel":"unix","subChannel":"general","sourceUrl":null,"videos":{"shortVideo":null,"longVideo":null},"companies":["OpenAI","Tesla"],"eli5":null,"relevanceScore":null,"lastUpdated":"2025-12-25T01:16:49.217Z","createdAt":"2025-12-25 12:50:55"}],"subChannels":["fundamentals","general"],"companies":["Amazon","Apple","Google","Meta","Microsoft","OpenAI","Snap","Snowflake","Tesla"],"stats":{"total":3,"beginner":1,"intermediate":1,"advanced":1,"newThisWeek":3}}